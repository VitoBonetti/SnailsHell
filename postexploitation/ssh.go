package postexploitation

import (
	"SnailsHell/config"
	"SnailsHell/model"
	"fmt"
	"time"

	"golang.org/x/crypto/ssh"
)

// CheckSSHLogin attempts to log in to an SSH server using provided credentials.
func CheckSSHLogin(host *model.Host) {
	for portID, port := range host.Ports {
		if port.Service == "ssh" || portID == 22 {
			var ip string
			for hostIP := range host.IPv4Addresses {
				ip = hostIP
				break
			}
			if ip == "" {
				continue
			}

			addr := fmt.Sprintf("%s:%d", ip, portID)

			for _, cred := range config.Cfg.Credentials.SSH {
				result := model.SSHResult{
					PortID:  portID,
					Address: addr,
					User:    cred.User,
				}

				sshConfig := &ssh.ClientConfig{
					User: cred.User,
					Auth: []ssh.AuthMethod{
						ssh.Password(cred.Password),
					},
					HostKeyCallback: ssh.InsecureIgnoreHostKey(),
					Timeout:         10 * time.Second,
				}

				client, err := ssh.Dial("tcp", addr, sshConfig)
				if err != nil {
					result.Status = "Login failed"
					result.Error = err.Error()
					host.SSHResults = append(host.SSHResults, result)
					continue
				}

				session, err := client.NewSession()
				if err != nil {
					result.Status = "Session creation failed"
					result.Error = err.Error()
					host.SSHResults = append(host.SSHResults, result)
					client.Close()
					continue
				}

				// Try to get the working directory as a simple success check
				output, err := session.CombinedOutput("pwd")
				if err != nil {
					result.Status = "Command execution failed"
					result.Error = err.Error()
					host.SSHResults = append(host.SSHResults, result)
				} else {
					result.Status = "Login successful"
					result.Successful = true
					result.Output = string(output)
				}

				host.SSHResults = append(host.SSHResults, result)
				session.Close()
				client.Close()
				// If we have a successful login, don't try other credentials for this port
				if result.Successful {
					break
				}
			}
		}
	}
}
